## Значения и типы

Как мы условились в главе 1, в JavaScript типизированные значения, а не типизированные переменные. Доступны следующие встроенные типы:
* `string` (строка)
* `number` (число)
* `boolean` (логическое значение)
* `null` и `undefined` (пустое значение)
* `object` (объект)
* `symbol` (символ, новое в ES6)

array и function -  о них следует думать скорее как о подтипах — особых версиях типа object.


```js
var a = "hello world";
a.toUpperCase();		// "HELLO WORLD"

```
Когда вы используете примитивное значение, такое как "hello world", подобно объекту, ссылаясь на свойство или метод (к примеру, a.toUpperCase()), JS автоматически "упаковывает" значение в его обертку-двойника (скрытую внутри).
Значение типа string может быть обернуто объектом String, значение типа number может быть обернуто объектом Number, а boolean может быть обернуто объектом Boolean.


```js
var a = 41;
var b = "42";
var c = "43";

a < b;		// true
b < c;		// true
```
если оба значения в сравнении < являются строками, то сравнение производится лексикографически (т.е. в алфавитном порядке, как в словаре), но если одно или оба значения не являются строками, как в случае с a < b, то оба значения приводятся к числу, и происходит типичное числовое сравнение.

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```
Подождите-ка, как это все эти три сравнения могут быть `false`? Так как значение `b` приводится к "некорректному числовому значению" `NaN` в сравнениях `<` и `>`, а спецификация говорит, что `NaN` не больше и не меньше, чем любое другое значение.

## Идентификатор `this`
```js
function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

//--------

foo();				// "global"
obj1.foo();			// "obj1"
foo.call( obj2 );	// "obj2"
new foo();			// undefined
```

Есть четыре правила того, как устанавливается `this`, и они показаны в этих четырех последних строках кода.

1. `foo()` присваивает в `this` ссылку на глобальный объект в нестрогом режиме. В строгом режиме, `this` будет `undefined`, и вы получите ошибку при доступе к свойству `bar`, поэтому `"global"` — это значение для `this.bar`.
2. `obj1.foo()` устанавливает `this` в объект `obj1`.
3. `foo.call(obj2)` устанавливает `this` в объект `obj2`.
4. `new foo()` устанавливает `this` в абсолютно новый пустой объект.