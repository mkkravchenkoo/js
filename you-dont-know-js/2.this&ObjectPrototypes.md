`this` не имеет ничего общего с определением функции, но зависит от того при каких условиях функция была вызвана.


Когда функция вызывается с указанием перед ней `new`, также известный как вызов конструктора, автоматически выполняются следующие вещи:

1. Создается новенький объект (т.е. конструируется) прямо из воздуха
2. *Только что сконструированный объект связывается с `[[Прототипом]]`*
3. Только что сконструированный объект устанавливается как привязка `this` для этого вызова функции
4. За исключением тех случаев, когда функция возвращает свой собственный альтернативный **объект**, вызов функции с `new` *автоматически* вернет только что сконструированный объект.

### Привязка по умолчанию

```js
function foo() {
	console.log( this.a );
}

var a = 2;

foo(); // 2
```


## 4 правила привязки `this` в вызовах функций.

### Неявная привязка
```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

obj.foo(); // 2
```

### Явная привязка

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```



### Привязка `new`
```js
function foo(a) {
	this.a = a;
}

var bar = new foo( 2 );
console.log( bar.a ); // 2
```
Вызывая `foo(..)` с `new` впереди нее, мы конструируем новый объект и устанавливаем этот новый объект как `this` для вызова `foo(..)`. **Таким образом `new` — единственный путь, которым `this` при вызове функции может быть привязан.** Мы называем это *привязкой new*.

`Object.create(null)` — похож на `{ }`, но без передачи `Object.prototype`, поэтому он "более пустой", чем просто `{ }`.

Стрелочные функции обозначаются не ключевым словом `function`, а операцией `=>`, так называемой "жирной стрелкой". Вместо использования четырех стандартных `this`-правил, стрелочные функции заимствуют привязку `this` из окружающей (функции или глобальной) области видимости.

# Глава 3: Объекты

Объекты создаются двумя способами: декларативно (литерально) и с помощью конструктора.


Литеральный синтаксис:

```js
var myObj = {
key: value
// ...
};
```

Конструкторная форма:

```js
var myObj = new Object();
myObj.key = value;
```

В JS есть шесть основных типов:

* `string`
* `number`
* `boolean`
* `null`
* `undefined`
* `object`

`function` - это подтип объекта (технически, «вызываемый объект»). Говорят, что функции в JS это объекты «первого класса», поскольку в основном они являются обычными объектами и с ними можно работать как с любым другим объектом.
`array` - это тоже форма объекта с расширенным поведением.

### Встроенные Объекты

* `String`
* `Number`
* `Boolean`
* `Object`
* `Function`
* `Array`
* `Date`
* `RegExp`
* `Error`


```js
var strPrimitive = "I am a string";
console.log( strPrimitive.length );	// 13
console.log( strPrimitive.charAt( 3 ) );	// "m"
```

В обоих случаях мы вызываем свойство или метод строчного примитива и движок автоматически преобразует его к объекту `String`, так что свойство/метод работают.

### Дублирование Объектов

```js
function anotherFunction() { /*..*/ }
var anotherObject = {
    c: true
};
var anotherArray = [];
var myObject = {
    a: 2,
    b: anotherObject,	// ссылка, а не копия!
    c: anotherArray,	// еще одна ссылка!
    d: anotherFunction
};
anotherArray.push( anotherObject, myObject );
```

```js
var newObj = Object.assign( {}, myObject );
newObj.a;	                    // 2
newObj.b === anotherObject;	    // true
newObj.c === anotherArray;	    // true
newObj.d === anotherFunction;	// true
```

### Дескрипторы свойств

```js
var myObject = {};
Object.defineProperty( myObject, "a", {
    value: 2,
    writable: true, // может быть перезаписанно, или нет (значение нельзя изменить)
    configurable: true, // можем изменять описание дескриптора, используя всё тот же инструмент `defineProperty(..) + препятствует возможности использовать оператор delete`
    enumerable: true //появится ли свойство в определенных перечислениях свойств объекта, таких как цикл `for..in`
} );
myObject.a; // 2
```
**Примечание**: существует особенное исключение, о котором стоит помнить: если для свойства уже задано `configurable:false`, то `writable` может быть изменено с `true` на `false` без ошибки, но не обратно в `true` если оно уже `false`.

### Иммутабельность
#### Константа объекта

Комбинируя `writable:false` и `configurable:false` вы по сути можете создать *константу* (не может быть изменена, переопределенна или удалена) в качестве свойства объекта, вроде:
```js
var myObject = {};
Object.defineProperty( myObject, "FAVORITE_NUMBER", {
    value: 42,
    writable: false,
    configurable: false
} );
```

#### Запрет расширения
Если вы хотите запретить добавление новых свойств объекта, но в то же время оставить существующие свойства нетронутыми
```js
var myObject = {
    a: 2
};
Object.preventExtensions( myObject );
myObject.b = 3;
myObject.b; // undefined
```

#### Запечатывание
Метод `Object.seal(..)` создает «запечатанный» объект -- то есть принимает существующий объект и по сути применяет к нему `Object.preventExtensions(..)`, но также помечает все существующие свойства как `configurable:false`.

Таким образом, вы не можете не только добавлять свойства, но и переконфигурировать или удалить существующие (хотя вы всё еще *можете* изменять их значения).

#### Заморозка
Метод `Object.freeze(..)` создает замороженный объект, что означает, что он принимает существующий объект и по сути применяет к нему `Object.seal(..)`, но также помечает все свойства «доступа к данным» как `writable:false`, так, что их значения не могут быть изменены.
Этот подход дает наивысший уровень иммутабельности, который вы можете получить для самого объекта, поскольку он предотвращает любые изменения в объекте или его непосредственных свойствах (хотя, как сказано выше, содержимое любых других привязанных объектов не затрагивается).
Вы можете «глубоко заморозить» объект, применив `Object.freeze(..)` к объекту и рекурсивно перебрать все объекты, на которые он ссылается (которые еще не были затронуты) применив к ним `Object.freeze(..)`. Однако, будьте осторожны, поскольку это может затронуть другие (общие) объекты, которые вы не планировали менять.

### Геттеры и Сеттеры
дескриптор доступа - `get` и `set` 
дескриптор данных - правилаб которые задаются в `defineProperty`


```js
var myObject = {
    // определяем геттер для `a`
    get a() {
        return 2;
    }
};
myObject.a = 3;
myObject.a; // 2
```

```js
var myObject = {
    // определим геттер для `a`
    get a() {
        return this._a_;
    },
    // определим сеттер для `a`
    set a(val) {
        this._a_ = val * 2;
    }
};
myObject.a = 2;
myObject.a; // 4
```
### Существование

Мы можем спросить есть ли у объекта свойство, не запрашивая значение свойства:

```js
var myObject = {
    a: 2
};
("a" in myObject);	            // true - check in all chain prototypes
("b" in myObject);	            // false
myObject.hasOwnProperty( "a" );	// true - check only current level
myObject.hasOwnProperty( "b" );	// false
```

# Глава 4: Смешивая объекты "классов"
## Mixins - Примеси

Механизм объектов JavaScript не *автоматически* выполняет поведение копирования, когда вы «наследуете» или «создаете экземпляр». Проще говоря, в JavaScript нет «классов» для создания экземпляров, только объекты. И объекты не копируются в другие объекты, они *связываются вместе* (подробнее об этом в главе 5).

Поскольку наблюдаемое поведение классов в других языках подразумевает наличие копий, давайте рассмотрим, как разработчики JS **подделывают** поведение копирования *отсутствующего* в JavaScript классах с помощью примесей(Mixins). Мы рассмотрим два типа «примесей»: **явные** и **неявные**.

### Явные примеси

Давайте снова вернемся к нашему примеру «Транспортное средство» - `Vehicle` и «Автомобиль» - `Car`. Поскольку JavaScript не будет автоматически копировать поведение из `Vehicle` в `Car`, мы можем вместо этого создать утилиту, которая будет это делать. Такая утилита часто называется `extend(..)` многими библиотеками / фреймворками, но мы будем называть ее `mixin(..)` здесь для наглядности.

```js
// значительно упрощенный пример `mixin(..)`:
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		// копируем только если его еще нет
		if (!(key in targetObj)) {
			targetObj[key] = sourceObj[key];
		}
	}

	return targetObj;
}

var Vehicle = {
	engines: 1,

	ignition: function() {
		console.log( "Завожу двигатель." );
	},

	drive: function() {
		this.ignition();
		console.log( "Двигаюсь вперёд!" );
	}
};

var Car = mixin( Vehicle, {
	wheels: 4,

	drive: function() {
		Vehicle.drive.call( this );
		console.log( "Еду на всех моих " + this.wheels + " колёсах!" );
	}
} );
```

### Неявные примеси
```js
var Something = {
	cool: function() {
		this.greeting = "Привет, мир";
		this.count = this.count ? this.count + 1 : 1;
	}
};

Something.cool();
Something.greeting; // "Привет, мир"
Something.count; // 1

var Another = {
	cool: function() {
		// неявное смешивание `Something` с `Another`
		Something.cool.call( this );
	}
};

Another.cool();
Another.greeting; // "Привет, мир"
Another.count; // 1 (нет общего состояния с `Something`)
```

Шаблон примеси (как явный, так и неявный) часто используется для *эмуляции* поведения копирования классов, но это обычно приводит к уродливому и хрупкому синтаксису, например явному псевдополиморфизму (`OtherObj.methodName.call(this, ...)`), что часто приводит к усложнению понимания и поддержки кода.

# Глава 5: Прототипы


```js

function MyFunction(value1, value2) {
	this.value1 = value1;
	this.value2 = value2;
}

// create prototype
MyFunction.prototype.getSum = function () {
	return this.value1+this.value2;
};


var myObj = new MyFunction(1,2);

// call method from prototype
console.log(myObj.getSum()); // 3

console.log(myObj.__proto__) // reference to MyFunction.prototype
console.log(myObj.__proto__.constructor) // reference to MyFunction
```
Когда нам нужно создать много объектов, через `new MyFunction()` (ф-цию конструктор) и есть потребность в кастомных методах, их (методы) нужно переносить в `MyFunction.prototype`. 
Когда новые объекты буду созданы через `new MyFunction()`, в самих объектах не будет метода `getSum`, но он будет доступен благодаря прототипному наследованию.

Все наши обекты будут ссылаться на `MyFunction.prototype` из `myObj.__proto__`. При этом `myObj.__proto__.constructor` будет ссылаться на саму функцию `MyFunction`

Почему мы не сохраняем в прототипах свойства? Потому что они случайным образом могут быть перетерты.
```js

MyFunction.prototype.nestedObj = {v1:1, v2:2}; // Добавляем объект в свойства прототипа

myObj.nestedObj.v1 = 111; // изменяем свойство в первого объекта. В этом случае оно будет перезаписано в прототипе для всех. С примитивами будет работать нормально

console.log(myObj.nestedObj); // {v1: 111, v2: 2}
console.log(myObj2.nestedObj); // {v1: 111, v2: 2}  // второй объект тоже имеет измененное свойство

```
**лучше всего считать ссылку `__proto__` доступной только для чтения**



`Object.create(..)` - дает нам всю мощь (делегирование) механизма `__proto__`, но без ненужных сложностей вроде функции `new`,


```js
var ourPrototype = {
	something: function() {
		console.log( "Скажи что-нибудь хорошее..." );
	}
};

var bar = Object.create( ourPrototype );

bar.something(); // Скажи что-нибудь хорошее...
```

**Примечание:** `Object.create(null)` создат объект с пустым `.__proto__`


```js
var anotherObject = {
	a: 2
};

var myObject = Object.create( anotherObject, {
	b: {
		enumerable: false,
		writable: true,
		configurable: false,
		value: 3
	},
	c: {
		enumerable: true,
		writable: false,
		configurable: false,
		value: 4
	}
} );

myObject.hasOwnProperty( "a" ); // false
myObject.hasOwnProperty( "b" ); // true
myObject.hasOwnProperty( "c" ); // true

myObject.a; // 2
myObject.b; // 3
myObject.c; // 4
```

Второй аргумент `Object.create(..)` указывает свойства, которые будут добавлены в создаваемый объект,

# Глава 6: Делегирование поведения
Как вы уже знаете из Главы 5, механизм `__proto__` — это внутренняя ссылка, которая существует в одном объекте и ссылается на другой объект.
Эта ссылка используется при обращении к несуществующему свойству/методу первого объекта.